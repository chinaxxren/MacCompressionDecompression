//
//  FinderSync.swift
//  zipext
//
//  Created by chinaxxren on 2025/6/12.
//

import Cocoa
import FinderSync
import os.log

private let logger = OSLog(subsystem: "com.yourcompany.zip.zipext", category: "FinderSync")
private let appGroupID = "group.com.yourname.zip.unique" // IMPORTANT: MUST MATCH a group in Signing & Capabilities

class FinderSync: FIFinderSync {

    // Use shared user defaults
    private var sharedUserDefaults: UserDefaults? {
        return UserDefaults(suiteName: appGroupID)
    }

    override init() {
        super.init()
        
        os_log("‚úÖ FinderSync initialized.", log: logger, type: .debug)
        
        // We are observing the user's home directory.
        FIFinderSyncController.default().directoryURLs = [URL(fileURLWithPath: NSHomeDirectory())]
        
        os_log("üöÄ FinderSync launched from: %{public}@", log: logger, type: .debug, Bundle.main.bundlePath as NSString)
    }
    
    // MARK: - Primary Finder Sync protocol methods
    
    override func beginObservingDirectory(at url: URL) {
        // The user is now seeing the container's contents.
        // If they see it in more than one view at a time, we're only told once.
        os_log("beginObservingDirectoryAtURL: %{public}@", log: logger, type: .debug, url.path as NSString)
    }
    
    
    override func endObservingDirectory(at url: URL) {
        // The user is no longer seeing the container's contents.
        os_log("endObservingDirectoryAtURL: %{public}@", log: logger, type: .debug, url.path as NSString)
    }
    
    override func requestBadgeIdentifier(for url: URL) {
        os_log("requestBadgeIdentifierForURL: %{public}@", log: logger, type: .debug, url.path as NSString)
        
        // For demonstration purposes, this picks one of our two badges, or no badge at all, based on the filename.
        let whichBadge = abs(url.path.hash) % 3
        let badgeIdentifier = ["", "One", "Two"][whichBadge]
        FIFinderSyncController.default().setBadgeIdentifier(badgeIdentifier, for: url)
    }
    
    // MARK: - Menu and toolbar item support
    
    override func menu(for menuKind: FIMenuKind) -> NSMenu? {
        os_log("‚û°Ô∏è menu(for:) called.", log: logger, type: .debug)
        switch menuKind {
        case .contextualMenuForItems:
            os_log("   menuKind is .contextualMenuForItems", log: logger, type: .debug)
        case .contextualMenuForContainer:
            os_log("   menuKind is .contextualMenuForContainer", log: logger, type: .debug)
        case .contextualMenuForSidebar:
            os_log("   menuKind is .contextualMenuForSidebar", log: logger, type: .debug)
        case .toolbarItemMenu:
            os_log("   menuKind is .toolbarItemMenu", log: logger, type: .debug)
        @unknown default:
            os_log("   menuKind is unknown", log: logger, type: .debug)
        }
        
        let menu = NSMenu(title: "")

        // We only want to add a menu to the contextual menu for selected items.
        guard menuKind == .contextualMenuForItems else {
            os_log("‚ùå Guard failed: menuKind is not .contextualMenuForItems. Returning nil.", log: logger, type: .debug)
            // For debugging, let's return a disabled item to show the extension is alive.
            let item = NSMenuItem(title: "Êó†ÂèØÁî®Êìç‰Ωú", action: nil, keyEquivalent: "")
            item.isEnabled = false
            menu.addItem(item)
            return menu
        }
        
        let selectedItems = FIFinderSyncController.default().selectedItemURLs() ?? []
        os_log("   %d items selected.", log: logger, type: .debug, selectedItems.count)
        
        // Show decompression options if a single archive file is selected.
        if selectedItems.count == 1,
           let firstItem = selectedItems.first,
           isArchiveFile(firstItem) {
            
            let extractHereMenuItem = NSMenuItem(title: "Ëß£ÂéãÂà∞ÂΩìÂâçÊñá‰ª∂Â§π",
                                              action: #selector(extractHere(_:)),
                                              keyEquivalent: "")
            extractHereMenuItem.target = self
            menu.addItem(extractHereMenuItem)
            
            let extractToNewFolderMenuItem = NSMenuItem(title: "Ëß£ÂéãÂà∞Êñ∞Êñá‰ª∂Â§π",
                                                      action: #selector(extractToNewFolder(_:)),
                                                      keyEquivalent: "")
            extractToNewFolderMenuItem.target = self
            menu.addItem(extractToNewFolderMenuItem)
            
        } else if !selectedItems.isEmpty {
            // Otherwise, show compression options.
            let compressMenu = NSMenu(title: "ÂéãÁº©")
            
            // Common formats
            let formats: [(title: String, type: String, shortcut: String)] = [
                ("ÂéãÁº©‰∏∫ ZIP", "zip", "z"),
                ("ÂéãÁº©‰∏∫ 7Z", "7z", "7"),
                ("ÂéãÁº©‰∏∫ TAR", "tar", "t")
            ]
            
            for format in formats {
                let menuItem = NSMenuItem(title: format.title,
                                        action: #selector(compress(_:)),
                                        keyEquivalent: format.shortcut)
                menuItem.target = self
                menuItem.representedObject = format.type
                compressMenu.addItem(menuItem)
            }
            
            compressMenu.addItem(NSMenuItem.separator())
            
            // Compression level submenu
            let levelMenu = NSMenu(title: "ÂéãÁº©Á∫ßÂà´")
            let levels = [(title: "‰ΩéÔºàËæÉÂø´Ôºâ", level: "low"),
                         (title: "‰∏≠ÔºàÈªòËÆ§Ôºâ", level: "normal"),
                         (title: "È´òÔºàËæÉÊÖ¢Ôºâ", level: "high")]
            
            for level in levels {
                let levelItem = NSMenuItem(title: level.title,
                                         action: #selector(setCompressionLevel(_:)),
                                         keyEquivalent: "")
                levelItem.target = self
                levelItem.representedObject = level.level
                if level.level == sharedUserDefaults?.string(forKey: "CompressionLevel") ?? "normal" {
                    levelItem.state = .on
                }
                levelMenu.addItem(levelItem)
            }
            
            let levelMenuItem = NSMenuItem(title: "ÂéãÁº©Á∫ßÂà´", action: nil, keyEquivalent: "")
            levelMenuItem.submenu = levelMenu
            compressMenu.addItem(levelMenuItem)
            
            // Password protection option
            let passwordItem = NSMenuItem(title: "Ê∑ªÂä†ÂØÜÁ†Å",
                                        action: #selector(togglePasswordProtection(_:)),
                                        keyEquivalent: "p")
            passwordItem.target = self
            passwordItem.state = sharedUserDefaults?.bool(forKey: "UsePassword") ?? false ? .on : .off
            compressMenu.addItem(passwordItem)
            
            let compressMenuItem = NSMenuItem(title: "ÂéãÁº©", action: nil, keyEquivalent: "")
            compressMenuItem.submenu = compressMenu
            menu.addItem(compressMenuItem)
        }
        
        if menu.items.isEmpty {
            os_log("ü§î No menu items were created. Returning nil.", log: logger, type: .debug)
            return nil
        } else {
            os_log("‚úÖ Returning menu with %d items.", log: logger, type: .debug, menu.items.count)
            return menu
        }
    }
    
    private func isArchiveFile(_ url: URL) -> Bool {
        let supportedExtensions = ["zip", "7z", "rar", "tar", "gz", "bz2", "xz"]
        return supportedExtensions.contains(url.pathExtension.lowercased())
    }
    
    // MARK: - Actions
    
    @objc func compress(_ sender: NSMenuItem) {
        guard let type = sender.representedObject as? String else { return }
        communicateWithMainApp(action: "compress", type: type)
    }
    
    @objc func extractHere(_ sender: AnyObject?) {
        communicateWithMainApp(action: "decompress", createNewFolder: false)
    }
    
    @objc func extractToNewFolder(_ sender: AnyObject?) {
        communicateWithMainApp(action: "decompress", createNewFolder: true)
    }
    
    @objc func setCompressionLevel(_ sender: NSMenuItem) {
        guard let level = sender.representedObject as? String else { return }
        if let menu = sender.menu {
            menu.items.forEach { $0.state = .off }
        }
        sender.state = .on
        sharedUserDefaults?.set(level, forKey: "CompressionLevel")
    }
    
    @objc func togglePasswordProtection(_ sender: NSMenuItem) {
        sender.state = sender.state == .on ? .off : .on
        sharedUserDefaults?.set(sender.state == .on, forKey: "UsePassword")
    }
    
    // MARK: - Communication with Main App
    
    private func communicateWithMainApp(action: String, type: String? = nil, createNewFolder: Bool? = nil) {
        guard let items = FIFinderSyncController.default().selectedItemURLs() else {
            showError("Êó†Ê≥ïËé∑ÂèñÊâÄÈÄâÈ°πÁõÆ„ÄÇ")
            return
        }
        
        let paths = items.map { $0.path }.joined(separator: ",")
        guard let encodedPaths = paths.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
            showError("Êó†Ê≥ïÁºñÁ†ÅÊñá‰ª∂Ë∑ØÂæÑ„ÄÇ")
            return
        }
        
        var urlComponents = URLComponents(string: "zipapp://\(action)")
        var queryItems = [URLQueryItem(name: "files", value: encodedPaths)]
        
        if let type = type {
            queryItems.append(URLQueryItem(name: "type", value: type))
            let level = sharedUserDefaults?.string(forKey: "CompressionLevel") ?? "normal"
            let usePassword = sharedUserDefaults?.bool(forKey: "UsePassword") ?? false
            queryItems.append(URLQueryItem(name: "level", value: level))
            queryItems.append(URLQueryItem(name: "usePassword", value: String(usePassword)))
        }
        
        if let createNewFolder = createNewFolder {
            queryItems.append(URLQueryItem(name: "createNewFolder", value: String(createNewFolder)))
        }
        
        urlComponents?.queryItems = queryItems

        guard let url = urlComponents?.url else {
            showError("Êó†Ê≥ïÂàõÂª∫Áî®‰∫é‰∏é‰∏ªÂ∫îÁî®ÈÄö‰ø°ÁöÑURL„ÄÇ")
            return
        }
        
        NSWorkspace.shared.open(url)
    }
    
    private func showError(_ message: String) {
        DispatchQueue.main.async {
            let alert = NSAlert()
            alert.messageText = "ËÆøËææÊâ©Â±ïÈîôËØØ"
            alert.informativeText = message
            alert.alertStyle = .critical
            alert.addButton(withTitle: "Â•ΩÁöÑ")
            alert.runModal()
        }
    }
}

 